public abstract class Arithmetic extends Expression {

    public Expression value(Map<String, Expression> state) throws TypeError {
        long[] results = new long[arguments.length];

//        solution 1
        for (int pos = 0; pos < arguments.length; pos++) {
            if (arguments[pos] instanceof Constant constant) {
                //using double .value() to deal with any annoyances
                results[pos] = constant.value(state).value();

            } else if (arguments[pos] instanceof Reference reference) {
                results[pos] = reference.value(state).value();

            }

            results[pos] = valueAssist(arguments[pos]);
        }
        long result = this.perform(results);
        return new Constant(result);

//        solution 2
        int pos = 0;
        while (pos < arguments.length) {
            results[pos] = arguments[pos].value(state).value();
            pos++;
        }
        long result = this.perform(results);
        return new Constant(result);
    }

    private long valueAssist(Expression args) {

        return new Constant(this.perform(args));
    }

